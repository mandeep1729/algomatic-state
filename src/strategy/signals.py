"""Signal types and data structures for trading strategies."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class SignalDirection(Enum):
    """Direction of a trading signal."""

    LONG = "long"
    SHORT = "short"
    FLAT = "flat"

    def __str__(self) -> str:
        return self.value


@dataclass
class SignalMetadata:
    """Additional metadata for a signal.

    Attributes:
        regime_label: Current regime label (if available)
        regime_sharpe: Sharpe ratio of current regime
        pattern_match_count: Number of similar historical patterns found
        pattern_expected_return: Expected return from pattern matching
        pattern_confidence: Confidence score from pattern matching (0-1)
        momentum_value: Raw momentum value that generated the signal
        volatility: Current realized volatility
        custom: Dictionary for additional custom metadata
    """

    regime_label: int | None = None
    regime_sharpe: float | None = None
    pattern_match_count: int = 0
    pattern_expected_return: float = 0.0
    pattern_confidence: float = 0.0
    momentum_value: float = 0.0
    volatility: float = 0.0
    custom: dict[str, Any] = field(default_factory=dict)


@dataclass
class Signal:
    """A trading signal generated by a strategy.

    Attributes:
        timestamp: When the signal was generated
        symbol: Asset symbol (e.g., 'AAPL', 'SPY')
        direction: Long, short, or flat
        strength: Signal strength (0.0 to 1.0)
        size: Position size (in dollars or shares, depending on context)
        metadata: Additional signal metadata
    """

    timestamp: datetime
    symbol: str
    direction: SignalDirection
    strength: float = 1.0
    size: float = 0.0
    metadata: SignalMetadata = field(default_factory=SignalMetadata)

    def __post_init__(self) -> None:
        """Validate signal values."""
        if not 0.0 <= self.strength <= 1.0:
            raise ValueError(f"Signal strength must be between 0 and 1, got {self.strength}")
        if self.size < 0:
            raise ValueError(f"Signal size must be non-negative, got {self.size}")

    @property
    def is_entry(self) -> bool:
        """Check if this is an entry signal (long or short)."""
        return self.direction != SignalDirection.FLAT

    @property
    def is_exit(self) -> bool:
        """Check if this is an exit signal (flat)."""
        return self.direction == SignalDirection.FLAT

    @property
    def is_long(self) -> bool:
        """Check if this is a long signal."""
        return self.direction == SignalDirection.LONG

    @property
    def is_short(self) -> bool:
        """Check if this is a short signal."""
        return self.direction == SignalDirection.SHORT

    def with_size(self, size: float) -> "Signal":
        """Create a copy of this signal with a new size.

        Args:
            size: New position size

        Returns:
            New Signal with updated size
        """
        return Signal(
            timestamp=self.timestamp,
            symbol=self.symbol,
            direction=self.direction,
            strength=self.strength,
            size=size,
            metadata=self.metadata,
        )

    def with_strength(self, strength: float) -> "Signal":
        """Create a copy of this signal with a new strength.

        Args:
            strength: New signal strength (0-1)

        Returns:
            New Signal with updated strength
        """
        return Signal(
            timestamp=self.timestamp,
            symbol=self.symbol,
            direction=self.direction,
            strength=strength,
            size=self.size,
            metadata=self.metadata,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary.

        Returns:
            Dictionary representation of the signal
        """
        return {
            "timestamp": self.timestamp.isoformat(),
            "symbol": self.symbol,
            "direction": str(self.direction),
            "strength": self.strength,
            "size": self.size,
            "metadata": {
                "regime_label": self.metadata.regime_label,
                "regime_sharpe": self.metadata.regime_sharpe,
                "pattern_match_count": self.metadata.pattern_match_count,
                "pattern_expected_return": self.metadata.pattern_expected_return,
                "pattern_confidence": self.metadata.pattern_confidence,
                "momentum_value": self.metadata.momentum_value,
                "volatility": self.metadata.volatility,
                "custom": self.metadata.custom,
            },
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Signal":
        """Create signal from dictionary.

        Args:
            data: Dictionary with signal data

        Returns:
            Signal instance
        """
        metadata_data = data.get("metadata", {})
        metadata = SignalMetadata(
            regime_label=metadata_data.get("regime_label"),
            regime_sharpe=metadata_data.get("regime_sharpe"),
            pattern_match_count=metadata_data.get("pattern_match_count", 0),
            pattern_expected_return=metadata_data.get("pattern_expected_return", 0.0),
            pattern_confidence=metadata_data.get("pattern_confidence", 0.0),
            momentum_value=metadata_data.get("momentum_value", 0.0),
            volatility=metadata_data.get("volatility", 0.0),
            custom=metadata_data.get("custom", {}),
        )

        timestamp = data["timestamp"]
        if isinstance(timestamp, str):
            timestamp = datetime.fromisoformat(timestamp)

        direction = data["direction"]
        if isinstance(direction, str):
            direction = SignalDirection(direction)

        return cls(
            timestamp=timestamp,
            symbol=data["symbol"],
            direction=direction,
            strength=data.get("strength", 1.0),
            size=data.get("size", 0.0),
            metadata=metadata,
        )
